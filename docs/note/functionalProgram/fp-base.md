# functional_programing

## start FB

计算机科学中有两条截然相反的路径。一条是自下而上，从底层指令开始往上抽象（优先考虑性能），逐渐靠近数学。比如，一开始的 Unix 操作系统是用汇编写的，后来发现用汇编写程序太痛苦了，需要一些抽象，所以出现了高级语言 C，再后来由于各种编写应用的需求，出现了更高级的语言如 Python 和 JavaScript。另一条路径是自上而下的，直接从数学开始（Lambda 演算），不考虑性能和硬件状况，按需逐渐减少抽象。前一条路径明显占了主流，代表语言是 Fortran, C, C++, Pascal, 和 Java 等。后面一条路径不够实用，比较小众，代表语言是 Algo, LISP, Small Talk 和 Haskell 等。

这两个阵营肯定是有争论的。前者想劝后者从良：你别扔给我这么多函数，我没法不影响性能情况下处理那么多垃圾回收和函数调用！后者也想叫醒前者：不要过早深入硬件细节，你会把自己锁定在无法逆转的设计错误上！两者分道扬镳了 60 多年，这些年总算开始融合了。比如，新出现的程序语言如 Scala，Kotlin，甚至系统编程语言 Rust，都大量借鉴了函数式编程的思想。

学些高阶抽象还能帮助你更容易理解一些看起来很复杂的概念。转述一个例子。C++ 编程里面最高的抽象是模板元编程(Template Meta Programming)，据说很难懂。但是据 Bartosz Milewski 的解释，之所以这个概念难懂，是因为 C++ 的语言设计不适合表达这些抽象。如果你会 Haskell，就会发现其实一行代码就完成了。



## ref

[为什么要这样写程序](https://juejin.im/post/5c2b93c8e51d456d14582b93)



