#### 位运算

**左移操作 `<<` **： a << b, 将 A 的二进制表示的每一位向左移 B 位，左边超出的位截掉，右边不足的位补0

A = 1100 B = 2 A << B = 110000

**右移操作 `>>` **： A >> B , A >>> B, 右移操作分为算数右移和逻辑右移

算术右移是带符号的右移，逻辑右移是不带符号的右移。
- 算术右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数.

- 逻辑右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0.

**按位与 `&` **操作 a & b, 将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位都为1时，结果位才为1，否则为0.

**按位或 `|` **操作 a | b, 将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，结果位就为1，否则为0.

**按位非 `~` **操作 ~ a, 将A的二进制表示每一位进行取反操作，如果对应的二进制位为0，结果位为1，否则为0.

**按位异或 `^` **操作 a ^ b将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.

###### 1. 更新二进制位

给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）。

**样例**

给出 N = (10000000000)(二进制)，M = (10101)(二进制)， i = 2, j = 6

返回 N = (10001010100)(二进制)

**思路**

根据题意，可以有一个想法，将n中第i位到第j位的先置为0，然后，按位或m << i即可

具体做法是：
1. 将n中第i位到第j位的先置为0: 构造一个数从第i位到第j位都是1，其他位为0的数, 然后取反
    - -1先左移(31-j)位, 高位置0；
    - 然后再将((-1) << (31 -  j))逻辑右移(31 - j + i)位, 低位置0；
    - 然后再将((-1) << (31 -  j))逻辑右移(31 - j + i)位, 即得到第i位到第j位是1，其他位是0的数;

2. 按位或m << i
    - | (m << i)

###### 2. A + B 问题

给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符.

**样例**

如果 a=1 并且 b=2，返回3

**思路**

考虑使用**按位异或 `^` **操作, 异或又被称为 `不进位加法`，在这里我们需要弥补在异或中不产生进位的地方（1  ^ 1）

1. a & b 就是 a 和 b 中对应都为1的位置，a & b << 1 就是进位

2. a + b = (a & b) + (a & b << 1) = a2 + b2;

3. 令 a2 = (a & b), 令 b2 = (a & b << 1); // b2 会不断缩小至0，think about it

4. 循环，最终 b2 => 0, a2 => a

###### 3. O(1)时间检测2的幂次

用 O(1) 时间检测整数 n 是否是 2 的幂次。

**样例**

n=4，返回 true;

n=5，返回 false.

**思路**

`用 x & (x - 1) 用于消去x最后一位的1`

1. N如果是2的幂次，则N满足两个条件
    1. N >0 
    2. N的二进制表示中只有一个1 (4的二进制是100)

2. 所以使用N & (N - 1)将N唯一的一个1消去，应该返回0

###### 4. 二进制中有多少个1

计算在一个 32 位的整数的二进制表示中有多少个 1.

**样例**

给定 32 (100000)，返回 1

给定 5 (101)，返回 2

给定 1023 (1111111111)，返回 10

**思路**

`用 x & (x - 1) 用于消去x最后一位的1`

1. 不断使用 x & (x - 1) 消去x最后一位的1，并记录次数

2. 总共消去了多少次的次数即为整数的二进制表示中有多少个 1的数量。

**拓展**

如果要将整数A转换为B，需要改变多少个bit位？

思路：第i位上不相等，则需要改变这个bit位。所以问题转化为了A和B有多少个bit位不相同 => 转变成了计算A异或B之后这个数中1的个数

###### 5. Single Number III

Given 2*n + 2 numbers, every numbers occurs twice except two, find them.

**样例**

Given [1,2,2,3,4,4,5,3] return 1 and 5

**思路**

`a ^ b ^ b = a`

可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。

1. 假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res = x^y。并且res != 0

2. 那么我们可以找出res二进制表示中的某一位是1, 然后在数组中根据每项的某一位是否为1将整个数组分为两个部分，且x，y在不同的两个子数组中。

3. 将子数组的所有的数异或起来，就可以得到唯一的那个数。






