## 正则表达式

<p class="tip">正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。简单来说，用一种描述性语言去规定字符串的一种规则，如果符合，就匹配了，否则就是不匹配。</p>

#### 正则表达式基本语法

###### 元字符

具有特殊意义的正则表达式，为了更好描述需要`匹配`的字符串。

常见的元字符：

| 代码 | 描述                                                            |
| ---- | :-------------------------------------------------------------- |
| .    | 匹配除换行符以外的任意单个字符                                  |
| \w   | 匹配一个单字字符(字母、数字、下划线或汉字)，等价于 [A-Za-z0-9_] |
| \W   | 匹配一个非单字字符，等价于 [^a-za-z0-9_]                        |
| \s   | 匹配任意的空白符                                                |
| \S   | 匹配任意的空白符                                                |
| \d   | 匹配数字                                                        |
| \b   | 匹配单词的开始或者结束                                          |
| ^    | 匹配字符串的`开始`                                              |
| \$   | 匹配字符串的`结束`                                              |

###### 限定符

表示前面正则字符`重复的次数`

常用的限定符：

| 代码\语法 | 描述                                                             |
| --------- | :--------------------------------------------------------------- |
| \*        | 匹配前面的子表达式 0 次或多次，等价于 {0,}                       |
| +         | 匹配前面的子表达式 1 次或多次，等价于 {1,}                       |
| ？        | 匹配前面的子表达式 0 次或 1 次，等价于 {0,1}，非贪婪             |
| {n}       | n 是一个非负整数。匹配确定的 n 次。                              |
| {n,}      | n 是一个非负整数。至少匹配 n 次。                                |
| {n,m}     | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。 |

###### 定位符

定位符用来描述`字符串或单词的边界`

| 代码\语法 | 描述                                                                                                                 |
| --------- | :------------------------------------------------------------------------------------------------------------------- |
| ^         | 匹配输入字符串的`开始`位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。              |
| \$        | 匹配输入字符串的`结束`位置。如果设置了 RegExp 对象的 Multiline 属性，\$ 也匹配 '\n' 或 '\r' 之前的位置。             |
| \b        | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| \B        | 匹配一非个单词边界，与\b 相反                                                                                        |

###### 字符转义

如果你想查找本身具有特殊意义的元字符，如果直接使用就会产生问题，这时你就得使用 \ 转义字符来取消这些字符的特殊意义。

> `如希望使用 . 或 * 应该使用 \. 和 \* 。当然，要查找 \ 本身，你也得用 \\`

###### 字符类

有的时候只是想找元音字母 a,e,i,o,u，其他字母不需要怎么办?很明显 \w 不适合的。

那我们应该自定义自己需要的字符集,很简单，你`只需要在方括号里列出`它们就行了[a,e,i,o,u], 其实 \d 等于[0-9],而 \w 等于[a-z0-9A-Z_]

###### 分枝条件

你可以理解为逻辑运算里“或” => x|y 满足 x 或 y 中的其中之一

例如：
green|red 匹配 'green apple' 中的 'green' 和 'red apple' 中的 'red'

###### 分组

我们可以重复单个字符多次，但是怎么可以重复多个字符多次呢？？你可以`用小括号()来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了`

模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 'foo bar foo bar' 中前两个单词,每个小括号表示一个分组，1 和 2 是 `组号` 而 \1 表示第一个分组匹配。

例如：\b(\w+)\b\s+\1\b 可以用来匹配重复的单词，像 go go, 或者 kitty kitty

```js
/\b(\w+)\b\s+\1\b/.test('go go');
```

常用分组语法:

| 分类     |  代码/语法   | 说明                                                                 |
| -------- | :----------: | :------------------------------------------------------------------- |
| 捕获     |    (exp)     | 匹配 exp,并捕获文本到自动命名的组里                                  |
| 捕获     | (?<name>exp) | 匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?'name'exp)      |
| 捕获     |   (?:exp)    | 匹配 exp,不捕获匹配的文本，也不给此分组分配组号，非捕获括号          |
| 零宽断言 |   (?=exp)    | 匹配 exp 前面的位置，先行断言                                        |
| 零宽断言 |   (?<=exp)   | 匹配 exp 后面的位置，后行断言                                        |
| 零宽断言 |   (?!exp)    | 匹配后面跟的不是 exp 的位置，正向否定查找                            |
| 零宽断言 |   (?<!exp)   | 匹配前面不是 exp 的位置，反向否定查找                                |
| 注释     | (?#comment)  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

组号分配：

- 分组 0 对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．

###### 反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：

常用的反义代码：

| 代码/语法 | 说明                                       |
| --------- | :----------------------------------------- |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了 x 以外的任意字符                  |
| [^aeiou]  | 匹配除了 aeiou 这几个字母以外的任意字符    |

###### 贪婪与懒惰

`正则表达式默认是尽可能匹配多的字符`，以这个表达式为例：a.\*b，这样，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这`被称为贪婪匹配`。

但是很明显有时候我们需要`尽可能匹配少`的字符，那我们可以加 `限定符?`，a.\*?b，这样如果用它来搜索 aabab 的话，它会匹配整个字符串 aab 和 ab

懒惰限定符：

| 代码\语法 | 描述                              |
| --------- | :-------------------------------- |
| \*?       | 重复任意次，但尽可能少的重复      |
| +?        | 重复 1 到更多次，但尽可能少的重复 |
| ??        | 重复 0 到 1 次，但尽可能少的重复  |
| {n, m}?   | 重复 n 到 m 次，但尽可能少的重复  |
| {n,}?     | 重复 n 次或以上，但尽可能少的重复 |

###### 标志修饰符

正则表达式有五个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。

| 标志 | 描述                                                              |
| ---- | :---------------------------------------------------------------- |
| g    | 全局匹配 global                                                   |
| i    | 忽视大小写匹配 ignore                                             |
| m    | 多行匹配 multiple                                                 |
| y    | 类似 g ，但是有粘连特点（ES6 新增),匹配从目标字符串的当前位置开始 |
| u    | 用于处理大于 uFFFF 的字符（ES6 新增）                             |

#### 使用正则表达式

###### 创建一个正则表达式

- 正则表达式`字面量`方式

```js
/*
   /pattern/flags
*/
const regex = /ab+c/;
const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;
```

- 调用 RegExp 对象的`构造函数`方式

```js
/*
new RegExp(pattern [, flags])
*/
let regex = new RegExp('ab+c');
let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, 'gi');
let regex = new RegExp('^[a-zA-Z]+[0-9]*W?_$', 'gi');
```

<p class = "tip">正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。</p>

###### 使用正则表达式的方法

| 标志 | 描述| --------- | :--------------------------------------------------------------------------------------------------- |
| `exec` | 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。 |
| `test` | 一个在字符串中测试是否匹配的 RegExp 方法，它`返回true或false。` |
| `match` | 一个在字符串中执行查找匹配的 String 方法，它返回一个`数组`或者在未匹配到时返回 null。 |
| `search` | 一个在字符串中测试匹配的 String 方法，它返回匹配到的`位置索引`，或者在失败时返回-1。 |
| `replace` | 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。 |
| `split` | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 |

###### 1. 用户名正则

```js
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test('hey_dadaya'));
```

###### 2. 密码强度正则

```js
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log('==' + pPattern.test('heydadayA1#'));
```

###### 3. 整数正则

```js
//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test('42'));
//输出 true
console.log(negPattern.test('-42'));
//输出 true
console.log(intPattern.test('-42'));
```

###### 4. 数字正则

```js
//可以是整数也可以是浮点数
//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test('42.2'));
console.log(negPattern.test('-42.2'));
console.log(numPattern.test('-42.2'));
```

###### 5. Email 正则

```js
//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test('805360566@qq.com'));
```

###### 6. 手机号码正则

```js
//手机号正则
var mPattern = /^1[34578]\d{9}$/;
//输出 true
console.log(mPattern.test('13051577831'));
```

###### 7. 身份证号正则

```js
//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test('11010519880605371X'));
```

###### 8. URL 正则

```js
//URL正则
var urlP = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test('http://www.baidu.com'));
```

###### 9. IPv4 地址正则

```js
//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test('115.28.47.26'));
```

###### 10. 十六进制颜色正则

```js
//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test('#b8b8b8'));
```

###### 11. 日期正则

```js
//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test('2017-05-11'));
//输出 true
console.log(dP1.test('2017-15-11'));

//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test('2017-02-11'));
//输出 false
console.log(dP2.test('2017-15-11'));
//输出 false
console.log(dP2.test('2017-02-29'));
```

###### 12. QQ 号码正则

```js
//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test('65974040'));
```

###### 13. 微信号正则

```js
//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test('heydadaya_com'));
```

###### 14. 车牌号正则

```js
//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test('粤B39006'));
```

###### 15. 是否含有中文字符

```js
//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test('hey123haha哈'));
```

###### 16. 金钱格式化

```js
// 用正则魔法实现：
var test1 = '1234567890';
var format = test1.replace(/\B(?=(\d{3})+(?!\d))/g, ',');

console.log(format); // 1,234,567,890

// 非正则的优雅实现：
function formatCash(str) {
  return str
    .split('')
    .reverse()
    .reduce((prev, next, index) => {
      return (index % 3 ? next : next + ',') + prev;
    });
}
console.log(formatCash('1234567890')); // 1,234,567,890
```

#### 参考

[正则表达式 30 分钟入门教程](https://deerchao.net/tutorials/regex/regex.htm)

[MDN 正则 js](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
