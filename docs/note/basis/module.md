## 模块化

什么是模块化？简单来说就是：对于一个复杂的应用程序，与其将所有代码一股脑地放在一个文件当中，不如按照`一定的语法`，遵循`确定的规则（规范）`拆分成几个`互相独立`的文件。这些文件应该具有`原子`特性，也就是说，其内部完成共同的或者类似的逻辑，通过`对外暴露一些数据或调用方法`，与外部完成整合。

这样一来，每个文件彼此独立，开发者更容易开发和维护代码，模块之间又能够互相调用和通信，这是现代化开发的基本模式。

-   可复用性

-   可组织性

-   中心化

-   独立性

在 webpack 中定义：

1. 模块：

    > 在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。
    > 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。

2. 模块化
    > 模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。

### 早期“假”模块化时代：

（1）从代码可读性上，借助函数作用域来模拟实现「假」的模块化，我称其为`函数模式`，即将不同功能封装成不同的函数：

```js
// 各个函数在同一个文件中，混乱地互相调用，而且存在命名冲突的风险。这没有在根本上解决问题，只是从代码编写的角度，拆分成了更小的函数单元而已。
function f1() {
    //...
}
function f2() {
    //...
}
```

（2）`对象模式`，即利用对象，实现命名空间的概念：

```js
const module1 = {
   foo: 'bar',
   f11: function f11 () { //... },
   f12: function f12 () { //... },
}

const module2 = {
   data: 'data',
   f21: function f21 () { //... },
   f22: function f22 () { //... },
}

module1.f11()
console.log(module2.data)

// 未能解决module1 和 module2 中的数据并不安全的问题，任何开发者都可以修改：
module2.data = 'modified data'
```

（3）`IIFE 立即执行函数模式`: 构造一个私有的作用域，再通过闭包，将需要对外暴露的数据和接口输出

```js
const module = (function () {
    var foo = 'bar';
    var fn1 = function () {
        // ...
    };
    var fn2 = function fn2() {
        // ...
    };
    return {
        fn1: fn1,
        fn2: fn2
    };
})();

module.fn1();
```

### 规范标准时代

#### CommonJS

同步加载模块方式

在 Node.js 中使用，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。

注意点：

-   文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间。

-   模块可以被多次引用、加载。`在第一次被加载时，会被缓存`，之后都从缓存中直接读取结果。

-   加载某个模块，就是引入该模块的 module.exports 属性。

-   module.exports 属性`输出的是值的拷贝`，一旦这个值被输出，模块内再发生变化不会影响到输出的值。

-   模块加载顺序`按照代码引入的顺序`。

-   注意 module.exports 和 exports 的区别

#### AMD

AMD ：Asynchronous Module Definition，看到 「Asynchronous」，能够反映到它的模块化标准不同于 CommonJS，是异步的，完全贴合浏览器的。

背景：由于 Node.js 运行于服务器上，所有的文件一般都已经存在了本地硬盘中，不需要额外的网络请求去异步加载，因而 CommonJS 规范加载模块是同步的。只有加载完成，才执行后续操作。但是，如果放在浏览器环境中，我们都需要从服务器端获取模块文件，此时再采用同步的方式，显然就不合适了。这时候，社区上推出了 AMD 规范。

它规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要代码去实现，因此一个著名的库 —— require.js 应运而生，require.js 实现很简单：`通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。`

define 和 require 就是 require.js 在全局注入的函数。

#### CMD

CMD 规范整合了 CommonJS 和 AMD 规范的特点：Common Module Definition，类似 require.js，CMD 规范的实现为 sea.js。

AMD 和 CMD 的两个主要区别如下。

-   AMD 需要异步加载模块，而 CMD 在 require 依赖的时候，可以通过`同步`的形式（require），`也可以通过异步`的形式（require.async）。

-   `CMD 遵循依赖就近原则`，`AMD 遵循依赖前置原则`。也就是说，在 AMD 中，我们需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，我们只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。

#### UMD

UMD 全称：Universal Module Definition，看到 「Universal」，我们可以猜到它允许在环境中同时使用 AMD 与 CommonJS 规范，相当于一个整合。该模式的核心思想在于`利用立即执行函数根据环境来判断需要的参数类别`

### ES 原生时代

-   ES 模块的设计思想是`尽量静态化`，这样能保证`在编译时就确定模块之间的依赖关系`(目前其实是支持了动态导入了的，待补充相关内容)，每个模块的输入和输出变量也都是确定的。CommonJS 和 AMD 模块，无法保证前置即确定这些内容，只能在运行时确定。这是 ES 模块化和其他规范的显著不同。

-   第二个差别在于，CommonJS 模块输出的是一个值的拷贝，ES 模块`输出的是值的引用`。

#### 静态性

通过静态分析，能够分析出导入的依赖。如果导入的模块没有被使用，便可以通过 tree shaking 等手段减少代码体积，进而提升运行性能。这就是基于 ESM 实现 tree shaking 的基础。

静态性的局限：

-   只能在文件顶部 import 依赖

-   export 导出的变量类型严格限制

-   变量不允许被重新绑定，import 的模块名只能是字符串常量，即不可以动态确定依赖

这样的限制在语言层面带来的便利之一是：我们可以通过作用域分析，分析出代码里变量所属的作用域以及它们之间的引用关系，进而可以推导出变量和导入依赖变量的引用关系，在没有明显引用时，就可以进行去冗余。

#### tree shaking

目的就是减少应用中写出，但没有被实际运用的 JavaScript 代码。这样一来，无用代码的清除，意味着更小的代码体积，bundle size 的缩减，对用户体验起到了积极作用。

#### 浏览器中快速使用 ES 模块化

如果我们想在浏览器中使用原生 ES 模块方案，只需要在 script 标签上添加一个`type="module"`属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为 fallback 方案

```html
<script type="module">
    import module1 from './modole1';
</script>
<script type="nomodule">
    alert('not support module');
</script>
```

使用 type="module" 的另一个作用是`进行 ES Next 兼容性的嗅探`。因为支持 ES 模块化的浏览器，都支持 ES Promise 等特性，基于此，应用场景较多。

## ref (https://juejin.cn/post/6844903741020192776)[掘金]

```

```
